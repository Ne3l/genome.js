define("core/Gene", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Gene = /** @class */ (function () {
        function Gene(factor) {
            this.factor = factor;
            this.value = Math.random();
        }
        Gene.prototype.get = function () {
            return this.value * this.factor;
        };
        Gene.prototype.mutate = function () {
            this.value = Math.random();
        };
        return Gene;
    }());
    exports.Gene = Gene;
});
define("core/Blueprint", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Blueprint = /** @class */ (function () {
        function Blueprint() {
            this.properties = [];
        }
        Blueprint.prototype.add = function (factor, times) {
            if (times === void 0) { times = 1; }
            for (var i = 0; i < times; i += 1) {
                this.properties.push(factor);
            }
        };
        Blueprint.prototype.getProperties = function () {
            return this.properties;
        };
        return Blueprint;
    }());
    exports.Blueprint = Blueprint;
});
define("core/Chromosome", ["require", "exports", "core/Gene"], function (require, exports, Gene_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Chromosome = /** @class */ (function () {
        function Chromosome(blueprint) {
            if (blueprint === void 0) { blueprint = null; }
            this.genes = [];
            this.fitness = 0;
            if (blueprint) {
                this.initializeGenes(blueprint);
            }
        }
        Chromosome.prototype.initializeGenes = function (blueprint) {
            var _this = this;
            var properties = blueprint.getProperties();
            properties.map(function (property) {
                var gene = new Gene_1.Gene(property);
                _this.genes.push(gene);
            });
        };
        Chromosome.prototype.computeFitness = function (fitnessCalculation) {
            this.fitness = fitnessCalculation(this.genes);
        };
        Chromosome.fromDNA = function (genes) {
            var chromosome = new Chromosome();
            chromosome.genes = [];
            genes.map(function (gene) {
                var geneClone = Chromosome.copyGene(gene);
                chromosome.genes.push(geneClone);
            });
            return chromosome;
        };
        Chromosome.copyGene = function (gene) {
            // @ts-ignore
            return Object.assign(Object.create(Object.getPrototypeOf(gene)), gene);
        };
        Chromosome.prototype.mutate = function () {
            var pivot = Math.floor(Math.random() * this.genes.length);
            this.genes[pivot].mutate();
        };
        Chromosome.prototype.getFitness = function () {
            return this.fitness;
        };
        Chromosome.prototype.getLength = function () {
            return this.genes.length;
        };
        Chromosome.prototype.getGenes = function () {
            return this.genes;
        };
        return Chromosome;
    }());
    exports.Chromosome = Chromosome;
});
define("core/GenomeEvent", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GenomeEvent = /** @class */ (function () {
        function GenomeEvent() {
        }
        GenomeEvent.dispatch = function (eventType, data) {
            if (data === void 0) { data = {}; }
            GenomeEvent.listeners.map(function (listener) {
                if (listener.eventType === eventType) {
                    listener.callback(data);
                }
            });
        };
        GenomeEvent.on = function (eventType, callback) {
            GenomeEvent.listeners.push({
                eventType: eventType,
                callback: callback,
            });
        };
        GenomeEvent.listeners = [];
        return GenomeEvent;
    }());
    exports.GenomeEvent = GenomeEvent;
    var GenomeEventType;
    (function (GenomeEventType) {
        GenomeEventType["GENOME_EVENT_GENERATION_BEGIN"] = "GENOME_EVENT_GENERATION_BEGIN";
        GenomeEventType["GENOME_EVENT_GENERATION_END"] = "GENOME_EVENT_GENERATION_END";
        GenomeEventType["GENOME_EVENT_GENERATION_FINISH"] = "GENOME_EVENT_GENERATION_FINISH";
    })(GenomeEventType || (GenomeEventType = {}));
    exports.GenomeEventType = GenomeEventType;
});
define("core/Population", ["require", "exports", "core/Chromosome", "core/GenomeEvent"], function (require, exports, Chromosome_1, GenomeEvent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Population = /** @class */ (function () {
        function Population(size, blueprint) {
            this.index = 0;
            this.size = size;
            this.blueprint = blueprint;
            this.chromosomes = [];
            this.bestChromosome = new Chromosome_1.Chromosome();
            this.sumFitness = 0;
            this.mutationRate = 0.01;
            this.stopAt = null;
            this.cutOff = 0.3;
            this.initializeChromosomes();
        }
        Population.prototype.initializeChromosomes = function () {
            for (var i = 0; i < this.size; i += 1) {
                var chromosome = new Chromosome_1.Chromosome(this.blueprint);
                this.chromosomes.push(chromosome);
            }
        };
        Population.prototype.setFitnessCalculation = function (fitnessCalculation) {
            this.fitnessCalculation = fitnessCalculation;
        };
        Population.prototype.setStopAt = function (fitness) {
            this.stopAt = fitness;
        };
        Population.prototype.sortChromosomes = function () {
            this.chromosomes = this.chromosomes.sort(function (a, b) {
                return a.getFitness() > b.getFitness() ? -1 : 1;
            });
        };
        Population.prototype.selectBestChromosomes = function () {
            var _this = this;
            var pivot = Math.floor(this.chromosomes.length * this.cutOff);
            this.chromosomes.splice(this.chromosomes.length - pivot);
            this.sumFitness = 0;
            this.chromosomes.map(function (chromosome) {
                _this.sumFitness += chromosome.getFitness();
            });
        };
        Population.prototype.crossoverChromosomes = function () {
            var newChromosomes = [];
            for (var i = this.chromosomes.length; i < this.size; i += 1) {
                var chromosomeA = null;
                var chromosomeB = null;
                do {
                    chromosomeA = this.getRandomChromosome();
                    chromosomeB = this.getRandomChromosome();
                } while (!chromosomeA || !chromosomeB);
                if (chromosomeA && chromosomeB) {
                    var pivot = Math.floor(Math.random() * chromosomeA.getLength());
                    var genesA = chromosomeA.getGenes().slice(0, pivot);
                    var genesB = chromosomeB.getGenes().slice(pivot);
                    var newChromosome = Chromosome_1.Chromosome.fromDNA(genesA.concat(genesB));
                    newChromosomes.push(newChromosome);
                }
                else {
                    // console.error('Should not happen');
                }
            }
            this.chromosomes = this.chromosomes.concat(newChromosomes);
        };
        Population.prototype.setMutationRate = function (mutationRate) {
            this.mutationRate = mutationRate;
        };
        Population.prototype.setCutOff = function (cutOff) {
            this.cutOff = cutOff;
        };
        Population.prototype.mutateChromosomes = function () {
            var _this = this;
            this.chromosomes.map(function (chromosome) {
                if (Math.random() < _this.mutationRate) {
                    chromosome.mutate();
                }
            });
        };
        Population.prototype.getRandomChromosome = function () {
            var random = Math.random() * this.sumFitness;
            var sumFitness = 0;
            for (var _i = 0, _a = this.chromosomes; _i < _a.length; _i++) {
                var chromosome = _a[_i];
                sumFitness += chromosome.getFitness();
                if (random < sumFitness) {
                    return chromosome;
                }
            }
            return null;
        };
        Population.prototype.shuffleChromosomes = function () {
            this.chromosomes = this.chromosomes.sort(function (a, b) {
                return Math.random() - 0.5;
            });
        };
        Population.prototype.keepBestChromosome = function () {
            if (this.bestChromosome) {
                if (this.bestChromosome.getFitness() < this.chromosomes[0].getFitness()) {
                    this.bestChromosome = this.copyChromosome(this.chromosomes[0]);
                }
            }
            else {
                this.bestChromosome = this.copyChromosome(this.chromosomes[0]);
            }
        };
        Population.prototype.copyChromosome = function (chromosome) {
            // @ts-ignore
            return Object.assign(Object.create(Object.getPrototypeOf(chromosome)), chromosome);
        };
        Population.prototype.run = function (rounds) {
            if (rounds === void 0) { rounds = 1; }
            if (!this.fitnessCalculation)
                throw new Error("You must specify a fitness calculation function using 'setFitnessCalculation'.");
            if (!this.blueprint)
                throw new Error('You must specify a blueprint to design your chromosomes.');
            for (var i = 0; i < rounds; i += 1) {
                this.index += 1;
                this.process();
                if (this.stopAt && this.bestChromosome.getFitness() >= this.stopAt) {
                    break;
                }
            }
            GenomeEvent_1.GenomeEvent.dispatch(GenomeEvent_1.GenomeEventType.GENOME_EVENT_GENERATION_FINISH, this.chromosomes);
        };
        Population.prototype.getGenerationNumber = function () {
            return this.index;
        };
        Population.prototype.getBestChromosome = function () {
            return this.bestChromosome;
        };
        Population.prototype.process = function () {
            var _this = this;
            GenomeEvent_1.GenomeEvent.dispatch(GenomeEvent_1.GenomeEventType.GENOME_EVENT_GENERATION_BEGIN, this.chromosomes);
            this.shuffleChromosomes();
            this.chromosomes.map(function (chromosome) {
                chromosome.computeFitness(_this.fitnessCalculation);
            });
            this.sortChromosomes();
            this.selectBestChromosomes();
            this.crossoverChromosomes();
            this.mutateChromosomes();
            this.keepBestChromosome();
            GenomeEvent_1.GenomeEvent.dispatch(GenomeEvent_1.GenomeEventType.GENOME_EVENT_GENERATION_END, this.chromosomes);
        };
        return Population;
    }());
    exports.Population = Population;
});
define("main", ["require", "exports", "core/Population", "core/Chromosome", "core/Gene", "core/Blueprint", "core/GenomeEvent"], function (require, exports, Population_1, Chromosome_2, Gene_2, Blueprint_1, GenomeEvent_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Population = Population_1.Population;
    exports.Chromosome = Chromosome_2.Chromosome;
    exports.Gene = Gene_2.Gene;
    exports.Blueprint = Blueprint_1.Blueprint;
    exports.GenomeEvent = GenomeEvent_2.GenomeEvent;
    exports.GenomeEventType = GenomeEvent_2.GenomeEventType;
});
/*
 * This example is based on the "infinite monkey theorem" (https://en.wikipedia.org/wiki/Infinite_monkey_theorem)
 *
 * The algorithm tries to reproduce a specific text input, here "helloworldhowareyoutoday" in a minimum generations.
 */
define("example", ["require", "exports", "main"], function (require, exports, main_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Defining the string to reproduce
    var answer = 'helloworldhowareyoutoday';
    // We create a blueprint to represent the data structure of a chromosome
    var blueprint = new main_1.Blueprint();
    // Our chromosomes will have 'answer.length' genes between 0 and 26 (not included), so that each gene can represent one letter of the alphabet
    blueprint.add(26, answer.length);
    // We generate a population of 500 chromosomes using our blueprint
    var population = new main_1.Population(500, blueprint);
    // Just some basic configurations
    population.setMutationRate(0.01);
    population.setCutOff(0.5);
    population.setStopAt(100); // We stop the processing when a chromosome reach AT LEAST 100 on his fitness
    // We define now the function that calculate the fitness of every chromosome on each generation
    // Be sure to never return 0 (cause a bug, WIP)
    population.setFitnessCalculation(function (genes) {
        var sum = 1; // Avoid to have 0 on fitness
        for (var i = 0; i < genes.length; i += 1) {
            var charCode = answer.charCodeAt(i) - 96;
            var geneCharCode = Math.floor(genes[i].get());
            // If the gene value is corresponding with the answer letter at the same location, then increment 'sum'
            if (charCode === geneCharCode) {
                sum += 1;
            }
        }
        // Basically a percent of correct genes' values
        return (sum / (genes.length + 1)) * 100;
    });
    // We wait for a generation to end, and we display the best chromosome fitness into the console
    main_1.GenomeEvent.on(main_1.GenomeEventType.GENOME_EVENT_GENERATION_END, function (chromosomes) {
        var bestChromosome = chromosomes[0];
        console.log("Generation " + population.getGenerationNumber() + ": " + bestChromosome.getFitness());
    });
    // Once the process in finished (when a chromosome reach the fitness limit or the process has reach the round limit), we display the string contained in its genes
    main_1.GenomeEvent.on(main_1.GenomeEventType.GENOME_EVENT_GENERATION_FINISH, function (chromosomes) {
        var finalString = '';
        var bestChromosome = chromosomes[0];
        bestChromosome.getGenes().map(function (gene) {
            finalString += String.fromCharCode(gene.get() + 96);
        });
        console.log("Result (fitness: " + bestChromosome.getFitness() + "): " + finalString);
    });
    // We process the algorithm throught 500 rounds (more options comming soon)
    population.run(500);
});
