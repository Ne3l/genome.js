System.register("core/Gene", [], function (exports_1, context_1) {
    "use strict";
    var Gene;
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
            Gene = /** @class */ (function () {
                function Gene(factor) {
                    this.factor = factor;
                    this.value = Math.random();
                }
                Gene.prototype.get = function () {
                    return this.value * this.factor;
                };
                Gene.prototype.mutate = function () {
                    this.value = Math.random();
                };
                return Gene;
            }());
            exports_1("Gene", Gene);
        }
    };
});
System.register("core/Blueprint", [], function (exports_2, context_2) {
    "use strict";
    var Blueprint;
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [],
        execute: function () {
            Blueprint = /** @class */ (function () {
                function Blueprint() {
                    this.properties = [];
                }
                Blueprint.prototype.add = function (factor, times) {
                    if (times === void 0) { times = 1; }
                    for (var i = 0; i < times; i += 1) {
                        this.properties.push(factor);
                    }
                };
                Blueprint.prototype.getProperties = function () {
                    return this.properties;
                };
                return Blueprint;
            }());
            exports_2("Blueprint", Blueprint);
        }
    };
});
System.register("core/Chromosome", ["core/Gene"], function (exports_3, context_3) {
    "use strict";
    var Gene_1, Chromosome;
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [
            function (Gene_1_1) {
                Gene_1 = Gene_1_1;
            }
        ],
        execute: function () {
            Chromosome = /** @class */ (function () {
                function Chromosome(blueprint) {
                    if (blueprint === void 0) { blueprint = null; }
                    this.genes = [];
                    this.fitness = 0;
                    if (blueprint) {
                        this.initializeGenes(blueprint);
                    }
                }
                Chromosome.prototype.initializeGenes = function (blueprint) {
                    var _this = this;
                    var properties = blueprint.getProperties();
                    properties.map(function (property) {
                        var gene = new Gene_1.Gene(property);
                        _this.genes.push(gene);
                    });
                };
                Chromosome.prototype.computeFitness = function (fitnessCalculation) {
                    this.fitness = fitnessCalculation(this.genes);
                };
                Chromosome.fromDNA = function (genes) {
                    var chromosome = new Chromosome();
                    chromosome.genes = [];
                    genes.map(function (gene) {
                        var geneClone = Chromosome.copyGene(gene);
                        chromosome.genes.push(geneClone);
                    });
                    return chromosome;
                };
                Chromosome.copyGene = function (gene) {
                    // @ts-ignore
                    return Object.assign(Object.create(Object.getPrototypeOf(gene)), gene);
                };
                Chromosome.prototype.mutate = function () {
                    var pivot = Math.floor(Math.random() * this.genes.length);
                    this.genes[pivot].mutate();
                };
                Chromosome.prototype.getFitness = function () {
                    return this.fitness;
                };
                Chromosome.prototype.getLength = function () {
                    return this.genes.length;
                };
                Chromosome.prototype.getGenes = function () {
                    return this.genes;
                };
                return Chromosome;
            }());
            exports_3("Chromosome", Chromosome);
        }
    };
});
System.register("core/GenomeEvent", [], function (exports_4, context_4) {
    "use strict";
    var GenomeEvent, GenomeEventType;
    var __moduleName = context_4 && context_4.id;
    return {
        setters: [],
        execute: function () {
            GenomeEvent = /** @class */ (function () {
                function GenomeEvent() {
                }
                GenomeEvent.dispatch = function (eventType, data) {
                    if (data === void 0) { data = {}; }
                    GenomeEvent.listeners.map(function (listener) {
                        if (listener.eventType === eventType) {
                            listener.callback(data);
                        }
                    });
                };
                GenomeEvent.on = function (eventType, callback) {
                    GenomeEvent.listeners.push({
                        eventType: eventType,
                        callback: callback,
                    });
                };
                GenomeEvent.listeners = [];
                return GenomeEvent;
            }());
            exports_4("GenomeEvent", GenomeEvent);
            (function (GenomeEventType) {
                GenomeEventType["GENOME_EVENT_GENERATION_BEGIN"] = "GENOME_EVENT_GENERATION_BEGIN";
                GenomeEventType["GENOME_EVENT_GENERATION_END"] = "GENOME_EVENT_GENERATION_END";
                GenomeEventType["GENOME_EVENT_GENERATION_FINISH"] = "GENOME_EVENT_GENERATION_FINISH";
            })(GenomeEventType || (GenomeEventType = {}));
            exports_4("GenomeEventType", GenomeEventType);
        }
    };
});
System.register("core/Population", ["core/Chromosome", "core/GenomeEvent"], function (exports_5, context_5) {
    "use strict";
    var Chromosome_1, GenomeEvent_1, Population;
    var __moduleName = context_5 && context_5.id;
    return {
        setters: [
            function (Chromosome_1_1) {
                Chromosome_1 = Chromosome_1_1;
            },
            function (GenomeEvent_1_1) {
                GenomeEvent_1 = GenomeEvent_1_1;
            }
        ],
        execute: function () {
            Population = /** @class */ (function () {
                function Population(size, blueprint) {
                    this.index = 0;
                    this.size = size;
                    this.blueprint = blueprint;
                    this.chromosomes = [];
                    this.bestChromosome = new Chromosome_1.Chromosome();
                    this.sumFitness = 0;
                    this.mutationRate = 0.01;
                    this.stopAt = null;
                    this.cutOff = 0.3;
                    this.initializeChromosomes();
                }
                Population.prototype.initializeChromosomes = function () {
                    for (var i = 0; i < this.size; i += 1) {
                        var chromosome = new Chromosome_1.Chromosome(this.blueprint);
                        this.chromosomes.push(chromosome);
                    }
                };
                Population.prototype.setFitnessCalculation = function (fitnessCalculation) {
                    this.fitnessCalculation = fitnessCalculation;
                };
                Population.prototype.setStopAt = function (fitness) {
                    this.stopAt = fitness;
                };
                Population.prototype.sortChromosomes = function () {
                    this.chromosomes = this.chromosomes.sort(function (a, b) {
                        return a.getFitness() > b.getFitness() ? -1 : 1;
                    });
                };
                Population.prototype.selectBestChromosomes = function () {
                    var _this = this;
                    var pivot = Math.floor(this.chromosomes.length * this.cutOff);
                    this.chromosomes.splice(this.chromosomes.length - pivot);
                    this.sumFitness = 0;
                    this.chromosomes.map(function (chromosome) {
                        _this.sumFitness += chromosome.getFitness();
                    });
                };
                Population.prototype.crossoverChromosomes = function () {
                    var newChromosomes = [];
                    for (var i = this.chromosomes.length; i < this.size; i += 1) {
                        var chromosomeA = null;
                        var chromosomeB = null;
                        do {
                            chromosomeA = this.getRandomChromosome();
                            chromosomeB = this.getRandomChromosome();
                        } while (!chromosomeA || !chromosomeB);
                        if (chromosomeA && chromosomeB) {
                            var pivot = Math.floor(Math.random() * chromosomeA.getLength());
                            var genesA = chromosomeA.getGenes().slice(0, pivot);
                            var genesB = chromosomeB.getGenes().slice(pivot);
                            var newChromosome = Chromosome_1.Chromosome.fromDNA(genesA.concat(genesB));
                            newChromosomes.push(newChromosome);
                        }
                        else {
                            // console.error('Should not happen');
                        }
                    }
                    this.chromosomes = this.chromosomes.concat(newChromosomes);
                };
                Population.prototype.setMutationRate = function (mutationRate) {
                    this.mutationRate = mutationRate;
                };
                Population.prototype.setCutOff = function (cutOff) {
                    this.cutOff = cutOff;
                };
                Population.prototype.mutateChromosomes = function () {
                    var _this = this;
                    this.chromosomes.map(function (chromosome) {
                        if (Math.random() < _this.mutationRate) {
                            chromosome.mutate();
                        }
                    });
                };
                Population.prototype.getRandomChromosome = function () {
                    var random = Math.random() * this.sumFitness;
                    var sumFitness = 0;
                    for (var _i = 0, _a = this.chromosomes; _i < _a.length; _i++) {
                        var chromosome = _a[_i];
                        sumFitness += chromosome.getFitness();
                        if (random < sumFitness) {
                            return chromosome;
                        }
                    }
                    return null;
                };
                Population.prototype.shuffleChromosomes = function () {
                    this.chromosomes = this.chromosomes.sort(function (a, b) {
                        return Math.random() - 0.5;
                    });
                };
                Population.prototype.keepBestChromosome = function () {
                    if (this.bestChromosome) {
                        if (this.bestChromosome.getFitness() < this.chromosomes[0].getFitness()) {
                            this.bestChromosome = this.copyChromosome(this.chromosomes[0]);
                        }
                    }
                    else {
                        this.bestChromosome = this.copyChromosome(this.chromosomes[0]);
                    }
                };
                Population.prototype.copyChromosome = function (chromosome) {
                    // @ts-ignore
                    return Object.assign(Object.create(Object.getPrototypeOf(chromosome)), chromosome);
                };
                Population.prototype.run = function (rounds) {
                    if (rounds === void 0) { rounds = 1; }
                    if (!this.fitnessCalculation)
                        throw new Error("You must specify a fitness calculation function using 'setFitnessCalculation'.");
                    if (!this.blueprint)
                        throw new Error('You must specify a blueprint to design your chromosomes.');
                    for (var i = 0; i < rounds; i += 1) {
                        this.index += 1;
                        this.process();
                        if (this.stopAt && this.bestChromosome.getFitness() >= this.stopAt) {
                            break;
                        }
                    }
                    GenomeEvent_1.GenomeEvent.dispatch(GenomeEvent_1.GenomeEventType.GENOME_EVENT_GENERATION_FINISH, this.chromosomes);
                };
                Population.prototype.getGenerationNumber = function () {
                    return this.index;
                };
                Population.prototype.getBestChromosome = function () {
                    return this.bestChromosome;
                };
                Population.prototype.process = function () {
                    var _this = this;
                    GenomeEvent_1.GenomeEvent.dispatch(GenomeEvent_1.GenomeEventType.GENOME_EVENT_GENERATION_BEGIN, this.chromosomes);
                    this.shuffleChromosomes();
                    this.chromosomes.map(function (chromosome) {
                        chromosome.computeFitness(_this.fitnessCalculation);
                    });
                    this.sortChromosomes();
                    this.selectBestChromosomes();
                    this.crossoverChromosomes();
                    this.mutateChromosomes();
                    this.keepBestChromosome();
                    GenomeEvent_1.GenomeEvent.dispatch(GenomeEvent_1.GenomeEventType.GENOME_EVENT_GENERATION_END, this.chromosomes);
                };
                return Population;
            }());
            exports_5("Population", Population);
        }
    };
});
System.register("main", ["core/Population", "core/Chromosome", "core/Gene", "core/Blueprint", "core/GenomeEvent"], function (exports_6, context_6) {
    "use strict";
    var Population_1, Chromosome_2, Gene_2, Blueprint_1, GenomeEvent_2;
    var __moduleName = context_6 && context_6.id;
    return {
        setters: [
            function (Population_1_1) {
                Population_1 = Population_1_1;
            },
            function (Chromosome_2_1) {
                Chromosome_2 = Chromosome_2_1;
            },
            function (Gene_2_1) {
                Gene_2 = Gene_2_1;
            },
            function (Blueprint_1_1) {
                Blueprint_1 = Blueprint_1_1;
            },
            function (GenomeEvent_2_1) {
                GenomeEvent_2 = GenomeEvent_2_1;
            }
        ],
        execute: function () {
            exports_6("Population", Population_1.Population);
            exports_6("Chromosome", Chromosome_2.Chromosome);
            exports_6("Gene", Gene_2.Gene);
            exports_6("Blueprint", Blueprint_1.Blueprint);
            exports_6("GenomeEvent", GenomeEvent_2.GenomeEvent);
            exports_6("GenomeEventType", GenomeEvent_2.GenomeEventType);
        }
    };
});
/*
 * This example is based on the "infinite monkey theorem" (https://en.wikipedia.org/wiki/Infinite_monkey_theorem)
 *
 * The algorithm tries to reproduce a specific text input, here "helloworldhowareyoutoday" in a minimum generations.
 */
System.register("example", ["main"], function (exports_7, context_7) {
    "use strict";
    var main_1, answer, blueprint, population;
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [
            function (main_1_1) {
                main_1 = main_1_1;
            }
        ],
        execute: function () {
            // Defining the string to reproduce
            answer = 'helloworldhowareyoutoday';
            // We create a blueprint to represent the data structure of a chromosome
            blueprint = new main_1.Blueprint();
            // Our chromosomes will have 'answer.length' genes between 0 and 26 (not included), so that each gene can represent one letter of the alphabet
            blueprint.add(26, answer.length);
            // We generate a population of 500 chromosomes using our blueprint
            population = new main_1.Population(500, blueprint);
            // Just some basic configurations
            population.setMutationRate(0.01);
            population.setCutOff(0.5);
            population.setStopAt(100); // We stop the processing when a chromosome reach AT LEAST 100 on his fitness
            // We define now the function that calculate the fitness of every chromosome on each generation
            // Be sure to never return 0 (cause a bug, WIP)
            population.setFitnessCalculation(function (genes) {
                var sum = 1; // Avoid to have 0 on fitness
                for (var i = 0; i < genes.length; i += 1) {
                    var charCode = answer.charCodeAt(i) - 96;
                    var geneCharCode = Math.floor(genes[i].get());
                    // If the gene value is corresponding with the answer letter at the same location, then increment 'sum'
                    if (charCode === geneCharCode) {
                        sum += 1;
                    }
                }
                // Basically a percent of correct genes' values
                return (sum / (genes.length + 1)) * 100;
            });
            // We wait for a generation to end, and we display the best chromosome fitness into the console
            main_1.GenomeEvent.on(main_1.GenomeEventType.GENOME_EVENT_GENERATION_END, function (chromosomes) {
                var bestChromosome = chromosomes[0];
                console.log("Generation " + population.getGenerationNumber() + ": " + bestChromosome.getFitness());
            });
            // Once the process in finished (when a chromosome reach the fitness limit or the process has reach the round limit), we display the string contained in its genes
            main_1.GenomeEvent.on(main_1.GenomeEventType.GENOME_EVENT_GENERATION_FINISH, function (chromosomes) {
                var finalString = '';
                var bestChromosome = chromosomes[0];
                bestChromosome.getGenes().map(function (gene) {
                    finalString += String.fromCharCode(gene.get() + 96);
                });
                console.log("Result (fitness: " + bestChromosome.getFitness() + "): " + finalString);
            });
            // We process the algorithm throught 500 rounds (more options comming soon)
            population.run(500);
        }
    };
});
